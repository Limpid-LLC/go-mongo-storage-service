name: Deploy to PROD

on:
  #push:
  #  branches:
  #    - prod
  workflow_dispatch:
jobs:
  deploy:
    runs-on: ubuntu-20.04
    environment: prod

    steps:
      - name: Checkout
        uses: actions/checkout@v2

      - uses: actions/setup-go@v4
        with:
          go-version: '>=1.17.0'
      - run: go version



      - name: Deploy
        env:
          IMAGE_NAME: ${{ vars.AWS_ECR }}/${{ github.event.repository.name }}
          SERVICE_NAME: ${{ github.event.repository.name }}
          NAMESPACE_NAME: ${{ vars.NAMESPACE_NAME}}
          IMAGE_TAG: latest
          AWS_ECR: ${{ vars.AWS_ECR }}
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          AWS_DEFAULT_REGION: ${{ vars.AWS_DEFAULT_REGION }}
          REPLICAS: ${{ vars.REPLICAS || '1' }}
          EKSCTL_VERSION: ${{ vars.EKSCTL_VERSION || '0.147.0' }}
          SSH_EC2_PRIVATE_KEY: ${{ secrets.SSH_EC2_PRIVATE_KEY }}
          EC2_REMOTE_USER: ${{ vars.EC2_REMOTE_USER }}
          EC2_REMOTE_SERVER: ${{ vars.EC2_REMOTE_SERVER }}
          EC2_REMOTE_DIR: ${{ vars.EC2_REMOTE_DIR }}
          CONNECTIONSTRING: ${{ secrets.CONNECTIONSTRING }}
          TOKEN: ${{ secrets.TOKEN }}
          DATABASE: ${{ secrets.DATABASE }}
          SSH_OPTIONS: "-o ServerAliveInterval=60 -o ServerAliveCountMax=10 -i /tmp/id_rsa"
        run: |
          
          export CONNECTIONSTRING TOKEN DATABASE
          cat config.json.tpl | envsubst > config.json
          echo "${SSH_EC2_PRIVATE_KEY}" | base64 -d > /tmp/id_rsa
          chmod 600 /tmp/id_rsa

          mkdir -p ~/.ssh
          ssh-keyscan "$EC2_REMOTE_SERVER" >> ~/.ssh/known_hosts
          
          #SERVICE_NAME=$(basename `git rev-parse --show-toplevel`)-$(git rev-parse --abbrev-ref HEAD)
          #DIR_TO_UPLOAD="./"
          #REMOTE_DIR=$EC2_REMOTE_DIR$SERVICE_NAME

          go get
          #ssh $SSH_OPTIONS "$EC2_REMOTE_USER@$EC2_REMOTE_SERVER" 'mkdir -p '$REMOTE_DIR
          #rsync -avz --delete-before -e "ssh $SSH_OPTIONS" --exclude '.git' $DIR_TO_UPLOAD "$EC2_REMOTE_USER@$EC2_REMOTE_SERVER:$REMOTE_DIR"
          # ssh $SSH_OPTIONS "$EC2_REMOTE_USER@$EC2_REMOTE_SERVER" 'set -x ;cd '$REMOTE_DIR' && bash deploy.sh $SERVICE_NAME'
          #ssh $SSH_OPTIONS "$EC2_REMOTE_USER@$EC2_REMOTE_SERVER" 'cd '$REMOTE_DIR' && make up'
          
 
          # ----------------------------------------------------------------------------------------------------
          #!/bin/bash
          #
          #if [ -e .msg ];then
            . .msg
          #else
          #  echo -e "\033[31m❌ can not open functions module... aborting\033[0m"
          #  exit 2
          #fi
          NAMESPACE=prod
          REPLICAS=1
          ECR=115297659436.dkr.ecr.eu-central-1.amazonaws.com
          #EC2_REMOTE_USER=ubuntu
          #EC2_REMOTE_SERVER=prod.f1xiq.com
          #EC2_REMOTE_DIR=/home/ubuntu/deploy/
          DIR_TO_UPLOAD="./"
          BUILD=$(date +%Y%m%d%H%m)
          GHORG=https://github.com/Limpid-LLC

          R=go-auth
          ECR_LOGIN="aws ecr get-login-password  | docker login --username AWS --password-stdin 115297659436.dkr.ecr.eu-central-1.amazonaws.com"
          $ECR_LOGIN

          echo -en "$MSG_INFO------------------------------------Deploying $R-----------------------------------\n"
          REPO=$GHORG/$R
          #echo -e "$MSG_INFO remove stale repo $R"
          #rm -rf $R
          #echo -e $MSG_INFO cloning $REPO
          #gh repo clone $REPO
          #if [ $? -eq 0 ];then
          #    pushd $R
          #    echo -e $MSG_TITLE checkout $NAMESPACE branch
          #    git checkout $NAMESPACE
          #    if [ $? -ne 0 ];then
          #      echo -e "$MSG_ERROR can not checkout branch $NAMESPACE $MSG_END"
          #      exit 2
          #    fi
          #    git pull
              SERVICE_NAME=$R
              #SERVICE_NAME=$(basename `git rev-parse --show-toplevel`)-auth
              REMOTE_DIR=$EC2_REMOTE_DIR$SERVICE_NAME
              TAG=$ECR/$SERVICE_NAME:$BUILD
              TAG_ROLLBACK=$ECR/$SERVICE_NAME:rollback
              TAG_PROD=$ECR/$SERVICE_NAME:prod
              # PORT=`grep EXPOSE Dockerfile |cut -d\  -f2 |head -1`
              PORT='-p 9080:9080 -p 9001:9080'
              set -a 
              source .env.$NAMESPACE
              set +a
              mv config.yml config.yml.tpl
              cat config.yml.tpl | envsubst > config.yml
              docker build --pull --progress plain -t $TAG .
              if [ $? -ne 0 ];then
                echo -e "$MSG_ERROR build failed $MSG_END"
                exit 2
              fi
              docker push $TAG
              if [ $? -ne 0 ];then
                echo -e "$MSG_ERROR can not push image $NAMESPACE $MSG_END"
                exit 2
              fi
              # RUN_CMD="docker-compose up -d --build --force-recreate --remove-orphans"
              #git clean -fxd
              ssh $SSH_OPTIONS "$EC2_REMOTE_USER@$EC2_REMOTE_SERVER" 'rm -rf '$REMOTE_DIR
              #rsync -avz --delete-before -e "ssh $SSH_OPTIONS" --exclude '.git' $DIR_TO_UPLOAD "$EC2_REMOTE_USER@$EC2_REMOTE_SERVER:$REMOTE_DIR"
              RUN_CMD="docker ps |grep go-auth |awk '{ print \$2}'"
              TAG_PREV=`ssh $SSH_OPTIONS "$EC2_REMOTE_USER@$EC2_REMOTE_SERVER" $RUN_CMD`
              RUN_CMD="docker tag $TAG_PREV $TAG_ROLLBACK; docker pull $TAG && docker image rm $TAG_PROD; docker tag $TAG $TAG_PROD"
              echo -e $MSG_TITLE $RUN_CMD
              ssh $SSH_OPTIONS "$EC2_REMOTE_USER@$EC2_REMOTE_SERVER" $RUN_CMD
              RUN_CMD="docker stop $SERVICE_NAME;docker rm $SERVICE_NAME; docker run $PORT --name $SERVICE_NAME -d $TAG"
              echo -e $MSG_TITLE $RUN_CMD
              ssh $SSH_OPTIONS "$EC2_REMOTE_USER@$EC2_REMOTE_SERVER" $RUN_CMD
              #ssh $SSH_OPTIONS "$EC2_REMOTE_USER@$EC2_REMOTE_SERVER" 'rm -rf '$REMOTE_DIR
              #ssh $SSH_OPTIONS "$EC2_REMOTE_USER@$EC2_REMOTE_SERVER" 'docker update --restart always $(docker ps -q)'
              popd
          fi

